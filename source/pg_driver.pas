{ ******************************************************************************

  Copyright (c) 2024 M van Delft.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  ****************************************************************************** }
unit pg_driver;

interface

uses System.SysUtils, System.Classes;

type
  TPgMessageEvent = procedure(const msg: string) of object;

  TPgDriver = class
  private
    FMessageEvent: TPgMessageEvent;
    procedure ExamineLine(const no: Integer; const line: string);
    procedure DoMessageEvent(const msg: string);
  public
    constructor Create;
    destructor Destroy;
    procedure ProcessFile(const fname: string; const enc: TEncoding);
    property OnMessageEvent: TPgMessageEvent read FMessageEvent
      write FMessageEvent;
  end;

implementation

uses System.Character, System.IOUtils;

{ TPgDriver }

constructor TPgDriver.Create;
begin
  // nop
end;

destructor TPgDriver.Destroy;
begin
  // nop
end;

procedure TPgDriver.DoMessageEvent(const msg: string);
begin
  if Assigned(FMessageEvent) then
    FMessageEvent(msg);
end;

procedure TPgDriver.ExamineLine(const no: Integer; const line: string);
var
  ar: TArray<Char>;
  col: Integer;
  fmt: string;
  s: string;
  bt: TBytes;
begin
  ar := line.ToCharArray();
  col := 0;
  fmt := '[%d, %d] <%s> - %s';
  for var c: Char in ar do
  begin
    Inc(col);
    if IsWhiteSpace(c) then
      // Zs category, or a tab ( U+0009 ), carriage return ( U+000D ), newline ( U+000A ), or form feed ( U+000C )
      s := Format(fmt, [no, col, c, 'whitespace'])
    else if IsLetter(c) then
      s := Format(fmt, [no, col, c, 'letter'])
    else if IsNumber(c) then
      s := Format(fmt, [no, col, c, 'number'])
    else if IsDigit(c) then
      s := Format(fmt, [no, col, c, 'digit'])
    else if IsPunctuation(c) then
      s := Format(fmt, [no, col, c, 'punctuation'])
    else if IsSymbol(c) then
      s := Format(fmt, [no, col, c, 'symbol'])
    else if IsSeparator(c) then // Zs space, Zl line, Zp paragraph
      s := Format(fmt, [no, col, c, 'separator'])
    else
      s := Format(fmt, [no, col, c, 'not classified']);
    bt := TEncoding.UTF8.GetBytes(c);
    for var b: Byte in bt do
      s := s + ' ' + IntToHex(b);
    // Generate event to update UI
    DoMessageEvent(s);
  end;
end;

procedure TPgDriver.ProcessFile(const fname: string; const enc: TEncoding);
var
  rdr: TStreamReader;
  ln: string;
  cnt: Integer;
begin
  // TODO: Move ProcessFile and ExamineLine to an object that drives
  // the lexer/parser/etc. This driver has no GUI.
  // Redefine Relation between driver object and the form.
  // Events generated by the driver to show information in the form????
  // TODO: Create Lexer Object
  // TODO: Add eventhandler procedure to form, and register with Lexer.
  // TODO: Call Lexer object to process characters.
  rdr := nil;
  cnt := 0;
  rdr := TStreamReader.Create(fname, enc);
  while not rdr.EndOfStream do
  begin
    Inc(cnt);
    ln := rdr.ReadLine;
    ExamineLine(cnt, ln);
  end;
  rdr.Close;
  rdr.Free;

end;

end.
