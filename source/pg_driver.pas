{ ******************************************************************************

  Copyright (c) 2024 M van Delft.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  ****************************************************************************** }
unit pg_driver;

interface

uses System.SysUtils, System.Classes, pg_lexer;

type
  TPgMessageEvent = procedure(const msg: string) of object;
  TPTokenEvent = procedure(const msg: string) of object;

  TPgDriver = class
  private
    FMessageEvent: TPgMessageEvent;
    FTokenEvent: TPTokenEvent;
    procedure ExamineLine(const no: Integer; const line: string);
    procedure DoMessageEvent(const msg: string);
    procedure DoTokenEvent(const msg: string);

    function ByteLine(const no: Integer; const line: string): string;
  public
    constructor Create;
    destructor Destroy; override;

    procedure ProcessFile2(const fname: string; const enc: TEncoding);
    procedure ProcessFile(const fname: string; const enc: TEncoding);
    property OnMessageEvent: TPgMessageEvent read FMessageEvent
      write FMessageEvent;
    property OnTokenEvent: TPTokenEvent read FTokenEvent write FTokenEvent;

    function ByteShowFile(const fname: string; const enc: TEncoding): TStrings;
  end;

implementation

uses System.Character, System.IOUtils;

{ TPgDriver }

function TPgDriver.ByteLine(const no: Integer; const line: string): string;
var
  ar: TArray<Char>;
  bt: TBytes;
  sb: TStringBuilder;
begin
  ar := line.ToCharArray();
  sb := TStringBuilder.Create;
  sb.Append(no);
  sb.Append(':');
  for var c: Char in ar do
  begin
    bt := TEncoding.UTF8.GetBytes(c);
    for var b: Byte in bt do
      sb.AppendFormat(' 0x%.2x', [b]);
    sb.Append(' -');
  end;
  Result := sb.ToString;
  sb.Free;
end;

function TPgDriver.ByteShowFile(const fname: string; const enc: TEncoding)
  : TStrings;
var
  rdr: TStreamReader;
  ln: string;
  cnt: Integer;
  lst: TStringList;
  s: string;
begin
  rdr := nil;
  cnt := 0;
  lst := TStringList.Create;
  rdr := TStreamReader.Create(fname, enc);
  while not rdr.EndOfStream do
  begin
    Inc(cnt);
    ln := rdr.ReadLine;
    lst.Add(IntToStr(cnt) + ': ' + ln);
    s := ByteLine(cnt, ln);
    lst.Add(s);
  end;
  rdr.Close;
  rdr.Free;
  Result := lst;
end;

constructor TPgDriver.Create;
begin
  // nop
end;

destructor TPgDriver.Destroy;
begin
  // nop
  inherited;
end;

procedure TPgDriver.DoMessageEvent(const msg: string);
begin
  if Assigned(FMessageEvent) then
    FMessageEvent(msg);
end;

procedure TPgDriver.DoTokenEvent(const msg: string);
begin
  if Assigned(FTokenEvent) then
    FTokenEvent(msg);
end;

procedure TPgDriver.ExamineLine(const no: Integer; const line: string);
var
  ar: TArray<Char>;
  col: Integer;
  s: string;
  bt: TBytes;
const
  fmt: string = '[%d, %d] <%s> - %s';
begin
  ar := line.ToCharArray();
  col := 0;
  for var c: Char in ar do
  begin
    Inc(col);
    if c.IsWhiteSpace then
      // Zs category, or a tab ( U+0009 ), carriage return ( U+000D ), newline ( U+000A ), or form feed ( U+000C )
      s := Format(fmt, [no, col, c, 'whitespace'])
    else if c.IsLetter then
      s := Format(fmt, [no, col, c, 'letter'])
    else if c.IsNumber then
      s := Format(fmt, [no, col, c, 'number'])
    else if c.IsDigit then
      s := Format(fmt, [no, col, c, 'digit'])
    else if c.IsPunctuation then
      s := Format(fmt, [no, col, c, 'punctuation'])
    else if c.IsSymbol then
      s := Format(fmt, [no, col, c, 'symbol'])
    else if c.IsSeparator then // Zs space, Zl line, Zp paragraph
      s := Format(fmt, [no, col, c, 'separator'])
    else
      s := Format(fmt, [no, col, c, 'not classified']);
    bt := TEncoding.UTF8.GetBytes(c);
    for var b: Byte in bt do
      s := s + ' ' + IntToHex(b);
    // Generate event to update UI
    DoMessageEvent(s);
  end;
end;

procedure TPgDriver.ProcessFile(const fname: string; const enc: TEncoding);
var
  rdr: TStreamReader;
  ln: string;
  cnt: Integer;
begin
  // TODO: Move ProcessFile and ExamineLine to an object that drives
  // the lexer/parser/etc. This driver has no GUI.
  // Redefine Relation between driver object and the form.
  // Events generated by the driver to show information in the form????
  // TODO: Create Lexer Object
  // TODO: Add eventhandler procedure to form, and register with Lexer.
  // TODO: Call Lexer object to process characters.
  rdr := nil;
  cnt := 0;
  rdr := TStreamReader.Create(fname, enc);
  while not rdr.EndOfStream do
  begin
    Inc(cnt);
    ln := rdr.ReadLine;
    ExamineLine(cnt, ln);
  end;
  rdr.Close;
  rdr.Free;

end;

procedure TPgDriver.ProcessFile2(const fname: string; const enc: TEncoding);
var
  lxr: TLexer;
  tok: TToken;
  tokman: TTokenManager;
  function TokTok: TToken;
  begin
    Result := tokman.NewToken;
    lxr.GetNextToken(Result);
    DoTokenEvent(Result.ToString);
  end;

begin
  lxr := nil;
  tokman := nil;
  try
    tokman := TTokenManager.Create;
    lxr := TLexer.Create(fname, enc);
    tok := TokTok;
    while tok.TokenType <> ttEOF do
      tok := TokTok;
  finally
    if Assigned(lxr) then
      lxr.Free;
    if Assigned(tokman) then
      tokman.Free;
  end;

end;

end.
